#!/usr/bin/env bash
# An easy way to manage all of your systemd timers
set -e
echo

# Make sure systemd is installed
#command -v systemctl >/dev/null 2>&1 || { echo -e \
#"I require systemd, but it's not installed.  Aborting.\n" >&2; exit 1; }

function disp_usage {
    echo -e "Usage:  $0 [-u|--user] COMMAND [ARGUMENT...]"
    echo -e "For more help:  $0 help\n"
    exit 1
}

function disp_help {
    echo "Usage: $0 [-u|--user] COMMAND [ARGUMENT...]"
    echo 'Manage your Systemd Timers'
    echo 'Only use one command at a time'
    echo
    echo '  -u, --user         Deal only with user timers (not run as root)'
    echo
    echo 'COMMANDS:'
    echo '  help               Display this help dialog'
    echo '  list               List the current timers'
    echo '  new [NAME...]      Create a new timer'
    echo '  enable [NAME...]   Enable timer'
    echo '  start [NAME...]    Start timer'
    echo '  stop [NAME...]     Stop timer'
    echo '  disable [NAME...]  Disable timer'
    echo '  remove [NAME...]   Remove (delete) timer and/or associated service files'
    echo '  modify [NAME...]   Opens the .timer file for editing in vi'
    echo '  convert            Convert a cron job into a Systemd timer'
    echo
    exit 0
}

function timer_options {
    echo 'AccuracySec='
    echo '    Specify the accuracy the timer shall elapse with. Defaults to 1min.'
    echo
    echo 'RandomizedDelaySec='
    echo '    Delay the timer by a randomly selected, evenly distributed amount of time'
    echo '    between 0 and the specified time value. Defaults to 0, indicating that no'
    echo '    randomized delay shall be applied.'
    echo
    echo 'Persistent=(true|false)'
    echo '    If true, the time when the service was last triggered is stored on disk.'
    echo '    The service unit is triggered immediately if the next run is missed.'
    echo '    This is useful to catch up on missed runs of the service when the machine'
    echo '    was off. Only use with OnCalendar= (realtime timers). Defaults to false.'
    echo
    echo 'WakeSystem=(true|false)'
    echo '    If true, an elapsing timer will cause the system to resume from suspend,'
    echo '    should it be suspended and if the system supports this. Defaults to false.'
    echo
    echo 'RemainAfterElapse=(true|false)'
    echo '    If true, an elapsed timer will stay loaded, and its state remains queriable.'
    echo '    If false, an elapsed timer unit that cannot elapse anymore is unloaded.'
    echo '    Turning this off is particularly useful for transient timer units that shall'
    echo '    disappear after they first elapse. Defaults to true.'
    echo
}

function time_syntax {
    echo 'VALUE [UNIT]'
    echo '    If no time unit is specified, seconds are assumed.'
    echo
    echo 'Possible units:'
    echo '    usec, us'
    echo '    msec, ms'
    echo '    seconds, second, sec, s'
    echo '    minutes, minute, min, m'
    echo '    hours, hour, hr, h'
    echo '    days, day, d'
    echo '    weeks, week, w'
    echo '    months, month, M (defined as 30.44 days)'
    echo '    years, year, y (defined as 365.25 days)'
    echo 'Examples:'
    echo '    2 h'
    echo '    2hours'
    echo '    48hr'
    echo '    1y 12month'
    echo '    55s500ms'
    echo '    300ms20s 5day'
    echo
}

function calendar_syntax {
    echo 'Examples for valid timestamps and their normalized form:'
    echo
    echo '  Sat,Thu,Mon..Wed,Sat..Sun → Mon..Thu,Sat,Sun *-*-* 00:00:00'
    echo '      Mon,Sun 12-*-* 2,1:23 → Mon,Sun 2012-*-* 01,02:23:00'
    echo '                    Wed *-1 → Wed *-*-01 00:00:00'
    echo '           Wed..Wed,Wed *-1 → Wed *-*-01 00:00:00'
    echo '                 Wed, 17:48 → Wed *-*-* 17:48:00'
    echo 'Wed..Sat,Tue 12-10-15 1:2:3 → Tue..Sat 2012-10-15 01:02:03'
    echo '                *-*-7 0:0:0 → *-*-07 00:00:00'
    echo '                      10-15 → *-10-15 00:00:00'
    echo '        monday *-12-* 17:00 → Mon *-12-* 17:00:00'
    echo '  Mon,Fri *-*-3,1,2 *:30:45 → Mon,Fri *-*-01,02,03 *:30:45'
    echo '       12,14,13,12:20,10,30 → *-*-* 12,13,14:10,20,30:00'
    echo '            12..14:10,20,30 → *-*-* 12,13,14:10,20,30:00'
    echo '  mon,fri *-1/2-1,3 *:30:45 → Mon,Fri *-01/2-01,03 *:30:45'
    echo '             03-05 08:05:40 → *-03-05 08:05:40'
    echo '                   08:05:40 → *-*-* 08:05:40'
    echo '                      05:40 → *-*-* 05:40:00'
    echo '     Sat,Sun 12-05 08:05:40 → Sat,Sun *-12-05 08:05:40'
    echo '           Sat,Sun 08:05:40 → Sat,Sun *-*-* 08:05:40'
    echo '           2003-03-05 05:40 → 2003-03-05 05:40:00'
    echo ' 05:40:23.4200004/3.1700005 → 05:40:23.420000/3.170001'
    echo '             2003-02..04-05 → 2003-02,03,04-05 00:00:00'
    echo '       2003-03-05 05:40 UTC → 2003-03-05 05:40:00 UTC'
    echo '                 2003-03-05 → 2003-03-05 00:00:00'
    echo '                      03-05 → *-03-05 00:00:00'
    echo '                     hourly → *-*-* *:00:00'
    echo '                      daily → *-*-* 00:00:00'
    echo '                  daily UTC → *-*-* 00:00:00 UTC'
    echo '                    monthly → *-*-01 00:00:00'
    echo '                     weekly → Mon *-*-* 00:00:00'
    echo '                     yearly → *-01-01 00:00:00'
    echo '                   annually → *-01-01 00:00:00'
    echo '                      *:2/3 → *-*-* *:02/3:00'
    echo
}

function list_timers {
    systemctl $user list-timers --all
    echo
    exit 0
}

function get_name {
    name="$1"
    # Prompt user for the name of the timer
    if [[ -z "$1" ]]; then
        read -rp "Name of timer: " name
        echo
    fi

    # Add the .timer extension if the user didn't specify it
    if [[ $(echo "$name" | rev | cut -d '.' -f 1 | rev) != "timer" ]]; then
        timer_prefix="$name"
        name="$name.timer"
    else
        timer_prefix=$(echo "$name" | rev | cut -d '.' -f 2- | rev)
    fi
}

function get_srvc_name {
    # Prompt user for the name of the service
    read -rp "Name of service: " srvc_name
    echo

    # Add the .service extension if the user didn't specify it
    if [[ $(echo "$srvc_name" | rev | cut -d '.' -f 1 | rev) != "service" ]]; then
        srvc_prefix="$srvc_name"
        srvc_name="$srvc_name.service"
    else
        srvc_prefix=$(echo "$srvc_name" | rev | cut -d '.' -f 2- | rev)
    fi
}

function get_path {
    # Set the path variable
    if [[ -n "$user" ]]; then # If the user option is set
        path=$USER_PATH
    else
        read -rp "Path to the timer: (/etc/systemd/system/) " path
        if [[ "$path" == '' ]]; then
            path="/etc/systemd/system/"
        # If the user left off the slash at the end, then add it
        elif [[ "${path: -1}" != '/' ]]; then
            path="$path/"
        fi
        echo
    fi
}

function get_srvc_path {
    # Set the srvc_path variable
    if [[ -n "$user" ]]; then # If the user option is set
        srvc_path=$USER_PATH
    else
        read -rp "Path to the service: (/etc/systemd/system/) " srvc_path
        if [[ "$srvc_path" == '' ]]; then
            srvc_path="/etc/systemd/system/"
        elif [[ "${srvc_path: -1}" != '/' ]]; then
            srvc_path="$srvc_path/"
        fi
        echo
    fi
}

function new_timer {
    get_name "$1"

    get_path

    # Create the directory, if necessary
    if [[ -n "$user" ]]; then mkdir -p $path; fi

    echo -e "Let's create a new timer called \"$name\"\n"
    timer_file="$path$name"

    # Prompt the user to see if we need to set the Unit= option.
    while [[ "$existing" != 'y' ]] && [[ "$existing" != 'n' ]]; do
        read -rp "Will this timer control an existing service? (y/N) " existing
        existing="$(echo "$existing" | tr '[:upper:]' '[:lower:]')"
        if [[ "$existing" == '' ]]; then existing="n"; fi
        echo
    done

    # If yes, then gather more information
    if [[ $existing == 'y' ]]; then
        get_srvc_name

        get_srvc_path
        srvc_file="$srvc_path$srvc_name"

        # If the service file doesn't exist...
        while [[ ! -e "$srvc_file" ]]; do
            echo "That service file does not exist in the default path ($path)"
            read -rp "Would you like to specify a different path? (y/N) " ans
            ans="$(echo "$ans" | tr '[:upper:]' '[:lower:]')"
            if [[ "$ans" == '' ]]; then ans="n"; fi
            if [[ "$ans" == 'y' ]]; then get_srvc_name; else exit 1; fi
        done

        if [[ ! -e "$srvc_file" ]]; then
            echo "The service file does not exist ($srvc_file)"
            exit 1
        fi
    # If no, then just set the appropriate variables
    elif [[ "$existing" == 'n' ]]; then
        srvc_prefix="$timer_prefix"
        srvc_name="$timer_prefix.service"
        srvc_path="$path"
        srvc_file="$srvc_path$srvc_name"
    fi

    # Creating the timer file & adding the description
    # '\e[4;37m' = Underline White
    # '\e[0m' = Text Reset
    echo -e "\n\e[4;37mLet's create the timer file\e[0m\n"
    read -rp "<$name> Description: " Description
    echo -e "[Unit]\nDescription=$Description\n\n[Timer]" > "$timer_file"

    # What type of timer will this be?
    echo -e '\nRealtime timers will activate at a specific time or day.'
    echo 'Monotonic timers will activate at specific intervals.'
    echo
    echo 'Create a realtime or monotonic timer?'
    PS3='Make a selection: '
    options=("Realtime" "Monotonic")
    select type in "${options[@]}"
    do
        case $type in
            "Realtime") break;;
            "Monotonic") break;;
            *) echo "Invalid option";;
        esac
    done
    echo

    # Setting timer frequencies
    if [[ $type == "Monotonic" ]]; then
        echo '(simply enter "s" without quotes to display the syntax)'
        read -rp 'How long should the timer wait after boot before being activated? ' OnBootSec

        if [[ "$OnBootSec" == "s" ]]; then
            echo
            time_syntax
            read -rp 'How long should the timer wait after boot before being activated? ' OnBootSec
        fi
        echo
        read -rp 'How frequently should the timer be activated after that? ' OnUnitActiveSec
        echo

        # Add this information to the timer file
        echo -e "OnBootSec=$OnBootSec\nOnUnitActiveSec=$OnUnitActiveSec" >> "$timer_file"
    elif [[ $type == "Realtime" ]]; then
        echo '(simply enter "s" without quotes to display the syntax)'
        read -rp 'Enter the calendar event expression: ' OnCalendar

        if [[ "$OnCalendar" == "s" ]]; then
            echo
            calendar_syntax
            read -rp 'Enter the calendar event expression: ' OnCalendar
        fi
        echo -e "OnCalendar=$OnCalendar" >> "$timer_file"
        echo
    fi

    # Prompt user for additional options for the timer
    echo 'Additional timer options:'
    PS3='Make a selection: '
    options=("AccuracySec=" "RandomizedDelaySec=" "Persistent=" "WakeSystem="
        "RemainAfterElapse=" "Display options help" "Done adding options")
    select type in "${options[@]}"
    do
        case $type in
            "AccuracySec=") read -rp 'Specify accuracy: (VALUE [UNIT]) ' AccuracySec; echo;;
            "RandomizedDelaySec=") read -rp 'Randomized delay: (VALUE [UNIT]) ' RandomizedDelaySec; echo;;
            "Persistent=") Persistent=true; echo -e 'Adding Persistent=true\n';;
            "WakeSystem=") WakeSystem=true; echo -e 'Adding WakeSystem=true\n';;
            "RemainAfterElapse=") RemainAfterElapse=false; echo -e 'Adding RemainAfterElapse=false\n';;
            "Display options help") echo; timer_options;;
            "Done adding options") break;;
            *) echo -e "Invalid option\n";;
        esac
    done

    if [[ -n "$AccuracySec" ]]; then echo "AccuracySec=$AccuracySec" >> "$timer_file"; fi
    if [[ -n "$RandomizedDelaySec" ]]; then echo "RandomizedDelaySec=$RandomizedDelaySec" >> "$timer_file"; fi
    if [[ -n "$Persistent" ]]; then echo "Persistent=$Persistent" >> "$timer_file"; fi
    if [[ -n "$WakeSystem" ]]; then echo "WakeSystem=$WakeSystem" >> "$timer_file"; fi
    if [[ -n "$RemainAfterElapse" ]]; then echo "RemainAfterElapse=$RemainAfterElapse" >> "$timer_file"; fi

    # Add the Unit= option to the timer file if necessary
    if [[ "$srvc_prefix" != "$timer_prefix" ]]; then
        echo "Unit=$srvc_file" >> "$timer_file"
    fi

    # Add the [Install] section
    echo -e '\n[Install]\nWantedBy=timers.target' >> "$timer_file"
    echo -e "\nThe following timer file has been created: $timer_file\n"

    # Creating the service file
    if [[ "$existing" == 'n' ]]; then
        echo -e "\n\e[4;37mLet's create the service file\e[0m\n"

        read -rp "<$srvc_name> Description: " Description
        read -rp 'What command/script should the service run? (absolute path only) ' ExecStart
        echo
        echo -e "[Unit]\nDescription=$Description\n" > "$srvc_file"
        echo -e "[Service]\nExecStart=$ExecStart\n" >> "$srvc_file"
        echo -e "[Install]\nWantedBy=default.target" >> "$srvc_file"

        echo -e "\nThe following service file has been created: $srvc_file\n"
    fi

    exit 0
}

function enable_timer {
    get_name "$1"

    # Try enabling the timer
    systemctl "$user" enable "$name"
    echo -e "$name has been enabled\n"

    exit 0
}

function start_timer {
    get_name "$1"

    # Try starting the timer
    systemctl "$user" start "$name"
    echo -e "$name has been started\n"

    exit 0
}

function stop_timer {
    get_name "$1"

    # Try stopping the timer
    systemctl "$user" stop "$name"
    echo -e "$name has been stopped\n"

    exit 0
}

function disable_timer {
    get_name "$1"

    get_path

    # Check if the timer exists
    if [[ ! -e "$path$name" ]]; then
        echo -e "That timer ($path$name) does not exist\n"
        exit 1
    else # If so, then disable it
        systemctl "$user" disable "$name"
        echo -e "$name has been disabled\n"
    fi

    exit 0
}

function remove_timer {
    get_name "$1"

    get_path

    # Prompt to remove associated service file
    while [[ $ans != 'y' ]] && [[ $ans != 'n' ]]; do
        read -rp "Remove the associated service file of the same prefix? (y/N) " ans
        ans=$(echo "$ans" | tr '[:upper:]' '[:lower:]')
        if [[ "$ans" == '' ]]; then ans="n"; fi
    done
    if [[ "$ans" == "y" ]]; then
        prefix=$(echo "$name" | rev | cut -d '.' -f 2- | rev) # Removing extension
        rm "$path$prefix.service"
    fi

    rm "$path$name"
    echo -e "$name has been removed\n"

    exit 0
}

function modify_timer {
    get_name "$1"

    get_path

    # Open the .timer file in the default editor specified by $EDITOR.
    # If that variable is not set, open in vi
    "${EDITOR:-vi}" "$path$name"
    
    exit 0
}

function convert {
    # Save the contents of crontab to a variable
    # If no crontab exists, then exit the script
    if ! crons=$(crontab -l); then echo; exit 1; fi
    
    # Strip the crontab file to just the list of cron jobs
    crons=$(echo "$crons" | grep '[^[:blank:]]' | grep -v '^#' | tr '\t' ' ')
    
    # Save each line to an array called 'lines'
    IFS=$'\r\n' GLOBIGNORE='*' command eval 'lines=($(echo "$crons"))'
    
    # Display each cron job
    for i in "${!lines[@]}"
    do
        echo "$(( i + 1 )).  ${lines[$i]}"
    done
    #echo "$(($i + 2)).  All"
    echo
    
    # Prompt the user for which job to convert to a timer
    while [[ "$job" -lt 1 || "$job" -gt ${#lines[@]} ]]; do
        read -rp 'Select which cron job to convert to a timer: ' job
    done
    echo
    
    #for i in "${lines[@]}"; do    For ALL cron jobs
    job=$(( job - 1 ))   # Because array elements start at 0
    # min hour dom month dow
    min=$(echo "${lines[$job]}" | cut -d ' ' -f 1)
    hour=$(echo "${lines[$job]}" | cut -d ' ' -f 2)
    dom=$(echo "${lines[$job]}" | cut -d ' ' -f 3)
    month=$(echo "${lines[$job]}" | cut -d ' ' -f 4)
    dow=$(echo "${lines[$job]}" | cut -d ' ' -f 5)
    cmd=$(echo "${lines[$job]}" | cut -d ' ' -f 6-)
    
    echo
    exit 0
}

# If no options are supplied, display usage & exit
if [[ $# == 0 ]]; then disp_usage; fi

# Make sure the user isn't using too many options
if [[ ( "$1" != "-u" && "$1" != "--user" ) && $# -gt 2 ]]; then
    echo -e "Only use one option at a time\n"
    disp_usage
elif [[ ( "$1" == "-u" || "$1" == "--user" ) && $# -gt 3 ]]; then
    echo -e "Only use one option at a time (not including the user option)\n"
    disp_usage
fi

# Set the path for when the --user option is specified
USER_PATH="$HOME/.config/systemd/user/"

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -u|--user ) user='--user';;
        help ) disp_help;;
        list ) list_timers;;
        new ) new_timer "$2"; shift;;
        enable ) enable_timer "$2"; shift;;
        start ) start_timer "$2"; shift;;
        stop ) stop_timer "$2"; shift;;
        disable ) disable_timer "$2"; shift;;
        remove ) remove_timer "$2"; shift;;
        modify ) modify_timer "$2"; shift;;
        convert ) convert "$2"; shift;;
        * ) disp_usage;;
    esac
    shift
done

# Features to implement:
#   - Allow user to convert all cron jobs into timers at once
